x
not x

noarg()
onearg(x)
2arg(
  1,
  2
)
2argtrailingcomma(
  1,
  2,
)

x + y * y + z/z *b

if x -> y
  printf
elif y => printy
else => dont


-- These 2 are equiv
x.y.z
x.
  y
  z

-- These 2 are equiv
vec.(x, y, z)
vec.(
  x,
  y,
  z
)

let x = 10

-- These 2 are equiv
let x = 11, y = 12
let
  x = 11
  y = 12

let Vec2 = struct:
  field
    x: f32
    y: f32

let Meal = enum:
  enum Breakfast
  enum Lunch
  enum Supper


-- elif/else/finally determine their location based on the indent of the leading if/for/while/etc
-- (Of course, it's recommended to write these as properly blocked structures, not with `=>`)
if x => if y => innerThen
        elif z => innerElIf
        else => innerElse
else => outerElse

-- Exception to the above: all is/else/finally must be indented from the leading `when`
when x+50 -> val
  is 10
    printf("It's 10")
  is 20
    printf("It's 20")
  else
    printf("Was neither")
  finally
    printf("Was either 10 or 20")

loop -> c
  break
else
  broke
finally
  didntBreak

for x -> val
  break
else
  broke
finally
  didntBreak
  
while true
  break
else
  broke
finally
  didntBreak


(=Vec3= x, y, z)
[1, 2, 3]
[.x, .y]

-- These 2 are functionally equivalent
[.x = 1, .y = 2,]
[
  .x =
    1
  -- Note that the dedent from the assignment block served as a comma
  -- This may be removed in the future.
  .y =
    2
]

let add = fn a: usize, b: usize -> c: usize = a + b

let foo =
  -- Blocking is suspended while parsing args
  fn a:usize,
     b:usize,
  -- And resumed when parsing the ret/body
  =>
    printf("Hey")

let ret10 = macro
  return 10

arr::map::reduce


not: true or false
-- functionally equivalent to not(true or false)

-- `:` calls are added to the most recent call
a(b): c
-- To `:` call a returned function, add `()`
a(b)(): c -- (Or just put it in the ())

arr::
  filter: fn each -> keep = each mod 2 == 0
  map: fn each -> new = each * 2

a::b::c::d
a::
  b
  c
  d
