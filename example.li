x
not x

noarg()
onearg(x)
2arg(
  1,
  2
)
2argtrailingcomma(
  1,
  2,
)

x + y * y + z/z *b

if x -> y
  printf
elif y => printy
else => dont


-- These 2 are equiv
x.y.z
x.
  y
  z

-- These 2 are equiv
vec.(x, y, z)
vec.(
  x,
  y,
  z
)

let x = 10

-- These 2 are equiv
let x = 11, y = 12
let
  x = 11
  y = 12

let Vec2 = struct:
  field
    x: f32
    y: f32

let Meal = enum:
  enum Breakfast
  enum Lunch
  enum Supper


-- elif/else/finally determine their location based on the indent of the leading if/for/while/etc
-- (Of course, it's recommended to write these as properly blocked structures, not with `=>`)
if x => if y => innerThen
        elif z => innerElIf
        else => innerElse
else => outerElse

-- Exception to the above: all is/else/finally must be indented from the leading `when`
when x+50 -> val
  is 10
    printf("It's 10")
  is 20
    printf("It's 20")
  else
    printf("Was neither")
  finally
    printf("Was either 10 or 20")

loop -> c
  break
else
  broke
finally
  didntBreak

for x -> val
  break
else
  broke
finally
  didntBreak
  
while true
  break
else
  broke
finally
  didntBreak


(=Vec3= x, y, z)
[1, 2, 3]
[.x, .y]

[.x = 1, .y = 2,]

let add = fn a: usize, b: usize -> c: usize = a + b

let foo =
  -- Blocking is suspended while parsing args
  fn a:usize
     b:usize -- (and commas are optional)
  -- And resumed upon reading the `=>`,`{}`, or `->` for parsing the ret/body
  =>
    printf("Hey")

let ret10 = macro =>
  return 10
let get10 = fn -> a =
  ret10()

arr::map::reduce


not: true or false
-- functionally equivalent to not(true or false)

-- `:` calls are added to the most recent call
a(b): c
-- To `:` call a returned function, add `()`
a(b)(): c -- (Or just put it in the ())

arr::
  filter: fn each -> keep = each mod 2 == 0
  map: fn each -> new = each * 2

a::b::c::d
a::
  b
  c
  d

-- Commas are actually optional in tups/arrays/structs
(
  a
  b
  -- You only need them when it is ambiguous, as below
  c,
  -d
  -- however, you could also write the above as
  c
  (-d)
  -- In other words, as long as you don't start an expression with `-`, you're fine
  -- to skip all commas in tups/arrays/structs
)
-- Optional commas are to better support things like
let funcs = overload [
  fn a, b -> c = a + b -- We *could* put a comma here, but why bother?
  fn c, d -> e = c / d
]
