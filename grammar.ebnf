(*
All ops in order of precedence:

= += -= *= /= |= &= <<= >>= ^=
or
and
|
^
&
== !=
< <= > >=
<< >>
+ -
* / %

- ! ~ ++ -- +++ ---

Field, optional, deref, addr-of, scope, call, index
. .? .* .addr :: () []

*)


capture = "|", id, "|";
tuple = "(", [expr, {",", expr}], ")";
(*Same as a tuple, but may only have IDs in it*)
idTuple = "(", id, {",", id}, ")";


literal = intLit | floatLit | boolLit | charLit | stringLit | nullLit;
val = id | literal;

accessOp = ".?" | ".*" | ".addr" | tuple | ("[", expr, "]");
subOp = "." | "::";
subExpr = val, {subOp, id}, {accessOp};

unaryOp = "-" | "!" | "~" | "++" | "+++" | "--" | "---";
unaryExpr = [unaryOp], subExpr;

productExpr = unaryExpr, {("*" | "/" | "%"), unaryExpr};
sumExpr = productExpr, {("+" | "-"), productExpr};
shiftExpr = sumExpr, {("<<" | ">>"), sumExpr};

relOp = "<" | ">" | "<=" | ">=";
relExpr = shiftExpr, {relOp, shiftExpr};

equalExpr = relExpr, {("==" | "!="), relExpr};
bitAndExpr = equalExpr, {"&", equalExpr};
xorExp = bitAndExpr, {"^", bitAndExpr};
bitOrExp = xorExpr, {"|", xorExpr};
andExpr = bitOrExpr, {"and", bitOrExpr};
orExp = andExpr, {"or", andExpr};

assignOp = ["+" | "-" | "*" | "/" | "|" | "&" | "<<" | ">>" | "^"],"=";
assignExpr = exp, [assignOp, orExp];

expr = assignExpr;

(*Following rust's semantics here.*)
exprList = {expr, ";"}, expr, [";"];

ifStmt = "if", expr, [":", capture], "{", exprList, "}";
(*while expr capture continuation loopOver*)
whileStmt = "while", expr, [":", capture], [":", expr], "{", exprList, "}", ["else", "{", exprList, "}"];
(*Basically just sugar for while on iterables*)
(*We'll follow the Zig iterate() fn idea for these*)
forStmt = "for", expr, [":", capture], "{", exprList, "}", ["else", "{", exprList, "}"];
