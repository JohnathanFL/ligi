(: Comments:
	(: This is a singleline comment
	let x = (: This is an inline comment :) 1;
	(: This is in the comment
	this is outside and invalid invalid. No multiline comments :)
(: On an unrelated note, don't you think zag comments are the happiest around? :)
comment = "(:" ... ( ":)" | \n )

(: Doc comment style. Normal comments are a note ( '(' ) delimited from the compiler ( ':' )
(: Doc comments are a note ( '(' ) assigned a function by the compiler ( '=' )
(: Note: doc comments currently don't support inlining. This is to disambiguate what they refer to.
doc_comment = "(="...\n

(:A single underscore shall be known as the sink variable.
(:Any writes to it are discarded, and it's used as a "don't care"
symbol = ("a".."z"|"A".."Z"), {"a".."z" | "A".."Z" | "0".."9" | "_"} | "_"
tuple = "(", [expr, {",", expr}], ")"
(:Same as a tuple, but may only have symbols in it
symbolTuple = "(", symbol, {",", symbol}, ")"

(: Anything bultin shall be prefixed with an @
builtin = "@" symbol

(: Instead of interfaces and such, we have concepts.
keyword = fn | purefn | if | for | while | let | var | break | match | struct | enum | union | concept | pub

(: These may be used as variable names, but are also intrinsic to variables as fields 
reservedFields = addr | deref


literal = intLit | floatLit | boolLit | charLit | stringLit | nullLit

(:
Basic language principles:


This language is whitespace insensitive.

Sigils shall be preferred over operators if possible without sacrificing readability

An effort will be made to keep programmers correct with programming (pointers/optionals/errors/etc). However...

An effort will be made to not baby/corall programmers with language constructs. 
We shall trust the programmers to not abuse constructs too much and shun those that do.

Code should flow, both in reading and writing.

Where possible, a language construct should have only one way of using it.
	For example, we use "case" instead of an if stmt for ternary stuff
	Promotes readability
	

Where possible, language constructs should follow a common syntax with only the initial keyword changing:
	This will promote code-reuse in the parser.
	All places that can bind a variable use the same parser module (let/var/caputures/arguments/etc)
	All control structures shall support a "finally" block.
		Iteration structures shall execute a finally block if the loop terminated normally.
		Selection structures shall excecute a finally block if one of the options was taken.
		In the case of a match stmt, it's (probably) useless but will be supported for consistency
	":" shall be known as the delimiter. It shall always be used when delimiting extra options in a stmt
		Loops shall follow the form <loop_keyword> expr [: caputure] [:continuation] block [finally block]
		If/Elif shall follow the form <if_keyword> expr [: capture] block (repeat) [finally block]
	"|...|" shall be used to capture things
	control statements (if, for, while...) shall follow "word expr brace" style. No extra parentheses
	" `label " defines a label named label. It can mark a stmt or block and allow returning a value from it
		(or arbitrarily breaking out of it)

snake_case, camelCase, and PascalCase shall all be acceptable as the programmer wishes.
Those using mashedtogethercase, however, shall be burned at the stake.


:)

(:
The ziggy-zaggy zenny:
	- Stop taking things *too* seriously
	- Trust programmers not to be too crazy, but leave options open for edge cases
	- The language exists to express the programmer's intent
	- The programmar's intent is to make a working program as intuitively as possible
	- What's been should tell you what's coming
	- Code should flow, both in reading and writing.
:)
label = "`"symbol

block = "{" {stmt} "}"
namedBlock = label block
anyBlock = namedBlock | block

stmt = bindStmt | ifStmt | forStmt | whileStmt | (expr ";") | block

(: The bindStmt after the typeTuple is how I'll do result locations.
(: The user will choose a new binding for the result, then write to it.
(: In this way, there will be no `return x` statement, only the break keyword,
(: with its optional scope specifier, which can be the name of the function 
type = {"?" | "!" | "[]" | "[" expr "]"} ( ("fn" | "purefn") typeTuple bindStmt | symbol)

bindStmt = ("let"|"var") symbol [":" type] ["=" expr] ";"

(: Allows capturing an optional, as in `if optVal : |val| {...}` 
ifCapture = "|" symbol "|"


ifStmt = "if" expr [":" ifCapture] block {elif expr [":" ifCapture] block} [else block]

(: 
If either of these symbols already exist, the capture will be use those variables.
Thus, you could do something like:
var count: usize = 0;
while someValIsTrue : |count| {...}
print("The count was: {}", count);

Note, however, that if the variable exists and does not have the appropriate type,
it shall be an error.
:)

loopCapture = "|" symbol ["," symbol] "|"

(: First expr is evaluated before each loop. Loop only continues if it's true 
(: Second expr is evaluated after each loop and the value discarded 
(: Finally blocks only execute if the entire loop finished. 
(: (i.e we're "finally" getting to it) 
whileStmt = "while" expr [":" loopCapture] [":" expr] anyblock ["finally" block]

(: First expr is only evaluated once, and is then looped over. 
(: We'll be following zig's new iterate() fn idea. 
forStmt = "for" expr [":" loopCapture] anyblock ["finally" block]

(: Used like an extended C++ ternary. You're picking which case is true 
(: Evaluated like an if (i.e only the first case that's true gets evaluated/returned) 
(: Example:

	let b = 15;
	let bIsTeen = case { b < 12 => false, else => true };
:)
(: Read it like "bIsTeen is, in the case of b < 12, false. Otherwise, it is true."
caseExpr = "case" "{" expr "=>" expr {"," expr "=>" expr} "," "else" "=>" expr "}"



(: A ternary or a field access (with func call or indexing) or literal or a tuple of values
(: Note: You may note there's no explicit (expr) ability here. This is because a single item
(: tuple will be implicitly convertible to .n0's type. In fact, I plan on doing this in parser.
val = caseExpr | accessExpr

baseVal = (symbol | literal | tuple)
(: a  value with an optional series of fields, function calls, or indexes
accessExpr = (symbol | literal | tuple) { "." symbol | tuple | "[" expr "]" } 


expr = assignExpr

(: All that follows here is expression stuff.
(: Slog through it if you like, but be warned it's dull.

(: All assignOps return the end result.
assignOp = "=" | "+=" | "-=" | "*=" | "/=" | "<<=" | ">>=" | "|=" | "&="
assignExpr = orExpr {assignOp (orExpr | namedBlock)}

orExpr = andExpr {"or" andExpr}
andExpr = relExpr {"and" relExpr}

(: Note the === operator is special, in that it returns nothing. It acts like an assert statement.
relOp = "==" | "!=" | "<" | ">" | "<=" | ">=" | "==="
relExpr = bitOrExp {relOp bitOrExp}

bitOrExp = bitXorExpr {"|" bitXorExpr}
bitXorExpr = bitAndExpr {"^" bitAndExpr}
bitAndExpr = shiftExpr {"&" shiftExpr}

shiftOp = "<<" | ">>" | ">>>"
(: The [] instead of {} here is no typo. Only 1 shift expr allowed at a time.
(: More than 1 will just get crazy.
shiftExpr = arithExpr [shiftOp arithExpr]

arithOp = "+" | "-"
arithExpr = prodExpr {arithOp prodExpr}

prodOp = "*" | "/" | "%"
prodExpr = unaryExpr {prodOp unaryExpr}

(: Note that the unary op applies to whatever's there AFTER evaluating dot operators and such
(: Note that we have [] instead of {}. Only one unary op may be used at a time.
(: Multiple unary ops must be applied with parenthesis
unaryOp = "-" | "!" | "~" | "++" | "--" | "+++" | "---"
unaryExpr = [unaryExpr] val


