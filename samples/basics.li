-- This sample is just a collection of random mini-samples that don't really
-- warrant their own files

-- IsEven. It should be its own package, but we'll include it here :)
let is_even = pure fn x -> isEven = x mod 2 == 0

-- Fizzbuzz
-- ..= is inclusive range [n,m], .. is [n,m)
for 0..=100 -> i => when (i mod 3, i mod 5)
  is (0, 0) => printf("FizzBuzz\n")
  is (0, _) => printf("Fizz\n")
  is (_, 0) => printf("Buzz\n")
  else => printf("{}\n", i)

-- Fibonacci
let fib = pure fn n -> f = when n
  is > 2 => fib(n - 1) + fib(n - 2)
  else => 1


-- Make and initialize a struct
let Food = struct {
  field name: str
  field calories: usize
}
let turkey = [.name = "Turkey", .calories = 1000]


-- Store an arbitrary enum
let t = #Taggy
assert t.@type == anyenum -- Objects have a special property called @type to get their type
assert t == #Taggy
-- Note that the tag (the part after #) can be any ligi word, including reserved words
-- If you want to restrict anyenum to a particular subset of values, you need a full enum


-- Make an enum
-- `enum` at the start of a statement is a bind specifier. `enum` in an expression is a unary op
-- Long form:
let Meal = enum {
  -- Could also combine these into one `enum Breakfast, Lunch, Supper` line
  enum Breakfast
  enum Lunch
  enum Supper
}
-- Shortest form:
let Meal = enum (Breakfast, Lunch, Supper)

let m = Meal.Breakfast
-- or
let m: Meal = #Breakfast

-- Make an algebraic data type:
let Health = enum {
  enum Dead
  enum Alive: usize
}

let h: Health = #Alive(100)
assert
  h != #Dead
  and h == #Alive -- Comparison against an anyenum (#Word) checks only the tag
  and h == #Alive(100) -- Comparison against a full enum literal (#Word(vals)) checks tag and vals
  and h == #Alive(_) -- Comparison against a sink (`_`) is always true, so this just checks the tag
  and h != #Alive(99)
  and h.Health == 99 -- Can also access it like a field. This would fail if h was #Dead


-- Largest element
let ar = [12, 5, 123, 64, 1235, 654]
let largest: ref const usize = {
  -- You can assign to a location from within its initializer.
  largest = ar[0].addr
  for ar -> el => if el > largest => largest = el.addr
}
assert largest == 1235
assert largest.addr == ar[4].addr

-- Reverse an array in place
var ar = [12, 5, 123, 64, 1235, 654]
for ar[0..ar.len/2] -> el, i => (el, ar.rev[i]) = (ar.rev[i], el)
-- .rev is a special property defined on arrays/slices that indexes in reverse.

-- Rotate an array in place n slots
var arr = [12, 5, 123, 64, 1235, 654]
-- The naive solution: Rotate n times in a row
let rotate = fn ar: ref _, n => when n
  is 0 {}
  is 1 => for (ar[0..ar.len], ar[1..ar.len]) -> (x, y) => (x, y) = (y, x)
  else => for 0..n => rotate(ar.addr, 1)
-- The optimized solution:
let rotate = fn ar: ref _, n =>
  for ar -> el, i {
    alias el2 = ar[(i + n) mod ar.len] -- aliases are lazily evaluated each time they're used
    (el, el2) = (el2, el)
  }


-- Sort an array: Simple bubble sort (in place)
let bubble_sort = fn items: slice _ =>
  for items -> x, i =>
    for items[i..items.len] -> y =>
      if y < x => (x, y) = (y, x)
-- Unit test
test "bubble_sort" {
  var ar     = [1, 6, 2, 3, 7, 1]
  let sorted = [1, 1, 2, 3, 6, 7]
  ar::bubble_sort()
  -- Don't ya love zipped iteration
  for (ar, sorted) -> (x, y) => assert x == y
}

-- List Interface
-- Ligi uses concepts to define "interfaces". By convention, we follow the `I` naming scheme.
-- Ligi follows Nim's concept of a "concept" definition, for the most part
-- Ligi just checks to see if the concept's block can pass type checking. Additionally,
-- comptime code (like asserts) are evaluated.
let IList = fn T: comptime type -> L = concept {
  -- @This is defined inside here, just as with struct and enum, and is the type
  -- we're checking against the idea of a List
  var list: @This -- Only checks type checking, so we don't need to give a value
  var el: T, optEl: ?T
  
  list.push(el)
  optEl = list.pop()
  list[0] = el -- check for both indexing and indexing as `ref T`
  -- A type which satisfies a concept is at least as good as it. Thus >= is `implements`
  assert list.insert(0, el).@type >= builtin.IResult(void)
}


-- Overloaded functions
let describe = overload (
  fn b: bool => printf("It's a bool"),
  fn i: isize => printf("It's an int")
)
describe(true) --= It's a bool
describe(-1) --= It's an int


-- Overloading operators
let Vec2 = struct {
  field x: f32, y: f32
  @overloads[#Add] += pure fn lhs, rhs -> res = [ .x = lhs.x + rhs.x, .y = lhs.y + rhs.y ]
}
let (v1, v2): (Vec2, Vec2) =  ([.x = 1, .y = 2], [.x = 2, .y = 1])
assert (v1 + v2) == [.x = 3, .y = 3]
-- Of course, the above is better accomplished by just using a tuple (f32,f32) and letting the
-- builtin overloads handle it

