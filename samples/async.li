(: This is to document stuff relating to Async and general threading


(: Basics

(: Ligi will assume a variable is only changed by the current thread unless its type is a volatile
let i: volatile usize = 10
(: 'volatile' is a volatile operator in that it doesn't stick around on re-assigns
assert i.@type == volatile usize
let j = i
assert j.@type == usize
(: This is so we're marking the location itself as volatile, not the value inside
(: Note that this doesn't affect things inside a pointer or slice
let ptr: volatile* volatile usize = i.&
let ptr2 = ptr
assert ptr2.@type == *volatile usize
(: I do, however plan to make it strip inside arrays, as they're value types
let ar: array volatile usize = [10, 20, 30, 40]
let ar2 = ar (: Array assignment copies. If you want a reference, use slices
assert ar2.@type == array usize
(: Once again, it sticks to the location not the value


(: Like volatile, I plan to make `atomic` an operator
let semaphore: atomic usize = 10
(: Like volatile, `atomic` is sticky to the location, not the value


(: Coroutines
(: Note that I have much to learn in this area. This may look like chicken scratchings.

(: If you're looking for a generator, just make a struct with an overloaded @for.
(: These coroutines are purely for cooperative *scheduling*
(: Coroutines take parameters once, then may suspend any number of times before returning a value once

(: I plan to basically follow Zig and Rust's lead

(: Asyncing a function call returns a stack frame struct for that function.
(: You can get the type of a function's frame with function.frame
  (: This frame may be called( () ) to resume it
  (: The result location is exposed as '.val', and whether it's ready is '.done'
    (: I originally wanted to expose the actual location, but that doesn't allow void functions
  (: When an async'd function returns a value, .val is valid and .done is true
  (: You can access interior variables according to normal struct access rules

let get_resource = fn resID:str -> res = {
  var canceled* = false
  let flag = send_off_request_for(resID)
  suspend
  while not is_ready(flag) {
    if canceled {
      (: Do special stuff to signal whatever we're requesting that we no longer need it
      (: Could also do this with a public 'cancel' function inside the routine
      break
    }
    suspend
  }
}

{
  var resFrame = async get_resource("https://example.com/image")
  while not resFrame.done { resFrame() }
  let res = resFrame.val
}
{
  var resFrame = async get_resource("https://example.com/slow_resource")
  while not resFrame.res.done -> _, i {
    if i > 10 {
      (: Took too long, we don't want it anymore
      resFrame.canceled = true
      break
    }
  }
}

(: You could also use the frame itself as a variable
(: Here's a lexer for the expression A + B - C + A implemented as a single function
let lex = fn input -> void = {
  let Token = enum {
    enum Var: char
    enum Add, Sub
  }
  var curTok+ = undef
  while not input.is_eof() {
    let cur = input.next_char()

    (: Using the current when structure proposal
    curTok = when cur
      is in ('A', 'B', 'B') { #Var(cur) }
      is '+' { #Add }
      is '-' { #Sub }
      else { return }
      (: As a side note, doesn't that read nice?
      (: 'curTok is, when cur is in the set {A, B, C}, a Var of cur. when cur is +, it is Add, etc
    
     suspend 
  } finally {
    curTok = #EOF
  }
}

var lexer = async lex()
while not lexer.done {
  printf("Got token {}", lexer.curTok)
  lexer()
}

(: This essentially allows a way of making a shorthand struct/FSM

(: Considerations
  (: Should we go with Zig's `resume frame` syntax to make things clearer?



(: Multithreading
(: I'm thinking of restricting passing pointers/slices across thread boundaries to only when
(: the inner type is volatile/atomic (and maybe introducing an unsafe keyword to force it)

