(: New Proposal: Overloadable functions
(: Rather than allow shadowing, why not just make functions work like operators
(: w.r.t overloading?

(: `overload` would be an operator which takes a block
  (: The block must only export functions
(: `overloaded` would be the type of its variable.
let show = overload {
  let fallback* = fn u -> void = printf("Hit fallback")
  let showBool* = fn b:bool -> void = printf("Hit showBool")
  let showISize* = fn i:isize -> void = printf("Hit showISize")
  let showString = fn s:str -> void = printf("I'm never hit because I'm not public!")
}
show("Test") (:= Hit fallback
show(10) (:= Hit fallback. (: overload won't try to coerce in this case.
show(true) (:= Hit showBool
show(-10) (:= Hit showISize

(: As you can see, things like show(10) may be annoying.
(: You can also access each functon directly:
show.showISize(10) (:= Hit showISize
