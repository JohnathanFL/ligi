(: In dev feature: switches/matches/whatever it ends up being
(: (Consider switch replacable with match in this document)


(: Option:  Standard Ziggy/Rusty style
let x = 10
switch x {
  10 => printf("Was 10"),
  else => printf("Wasn't 10")
}


(: Option: C#-ish style (a.k.a the binary option)
x switch {
  10 => printf("Was 10"),
  else => printf("Wasn't 10")
}
(: I'm immediately discarding this, as it would require switch to be a special binary operator


(: Option: "delayed operator" style
(: Essentially Ziggy style, but using binary operators to specify the operation used
match x {
  == 10 => printf("Was 10"),
  in 0..5 => printf("Was 0,1,2,3 or 4"),
  != 10 => printf("Wasn't 10"),
  else => unreachable
}
(: Cons:
  (: Somewhat less readable

(: Variant Option: "is delayed operator" style
(: Delayed operator style, but using 'is' to demarcate the binary operators
match x {
  is == 10 => printf("Was 10"),
  is in 0..5 => printf("..."),
  is != 10 => printf("Wasn't 10"),
  else => unreachable,
}
(: Pros: Very readable, still allows for different binary operators
(: Cons: Less writable than a pure Ziggy style.

(: Variant option: Ziggy or "is delayed operator" style
(: Use 'is' to figure out which style to use.
match x {
  10 => printf("Was 10"),
  is != 10 => printf("Wasn't 10")
}
(: I currently think this is the best way to go. It allows for 
