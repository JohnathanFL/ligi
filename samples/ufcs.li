-- This is about adding UFCS (universal function call syntax) to Ligi


-- There will be two parts in this proposal, which may be added together or separately:
---- 0: Searching local namespaces to resolve functions
---- 1: Calling functions without parentheses (i.e as unary or binary ops)



-- Part 0:
---- This would allow things like:
let add = pure fn a, b -> c = a + b
assert 1.add(2) == 1 + 2
-- Note that existing methods/properties would have precedence:
let val = pure fn a:?usize = b:bool = a.has
let v: ?usize = 10
assert v.val == 10 -- Not a bool

-- New way for Part 1:
-- Since `.` syntax makes it harder to differentiate between builtin methods and freestanding
-- functions, I propose adding the `::` operator, which would act as a function applier:
-- Inspiration from that C preprocessor dude in /r/ProgrammingLanguages on a UFCS thread
assert 1::add(2) == 3
let pow = fn x, y -> p = when y
  is 0 { 1 }
  is 1 { x }
  else { x * x::pow(y - 1) }
assert 2::pow(2) == pow(2, 2)

-- It wouldn't require () for single arg functions
-- Thus, 
let sqr = pure fn x -> y = x * x
assert 2::sqr == (2::sqr(), sqr(2))
-- I'm going to advise (as a style recommendation) that functions which don't return a value
-- always use () even if they have no args beyond the first :: arg, just because no ()
-- seems to be to look more like you're getting a value than performing an operation
-- (A bit like the advice to use snake_case for complex properties and camelCase for simple ones)


-- The `::` operator would work below unary operators, at the same level as the `.` operator:
assert foo::module.func(arg) == module(foo).func(arg)
-- Thus, you must qualify function names if truly needed with parens:
assert foo::(module.func)(arg) == module.func(foo, arg)
-- This is an intentional ugliness. If you want the function, you should just `use` it directly.

-- This new operator would also make formatting a little prettier:


"Hello, world"::printf() 
"Hello, {}."::printf("John")



-- Part 1:
---- This would allow things like this:
let neg = pure fn a -> b = -a
assert (neg 1) == -1

-- Would NOT allow things like this:
let add = pure fn a, b -> c = a + b
assert (4 add 6) == (4 + 6)
-- As allowing that would make it be parsed as `4(add)(6)`

-- This would make the type functions slightly more ergonomic:
let rc: Rc usize -- As it's now implicitly parsed as `Rc(usize)`
let arList: ArrayList usize


-- Major problem with Part 1: Ligi already returns values, and `symbol` on its own is a value.
-- Thus, we end up in Nim's scenario where you need to use () on solitary functions, like so:
let say_hi = fn -> void = printf("Hello, world!\n")
say_hi -- Returns a value of type `fn -> void`
say_hi() -- Calls say_hi and yields a value of type `void`
-- However the following is still fine as it has an argument:
let echo = fn msg: comptime str -> void = printf(msg)
echo "Hello, world!"

-- We could additionally allow multiple arguments (if comma separated)
printf "Hello, {}", "Johnathan"
-- This would still require parentheses around multiple invocations to remove ambiguity about
-- which function an argument binds to.
printf "1+2={}", add 1, 2    -- BAD - Parsed as printf("", add, 1, 2)
printf "1+2={}", (add 1, 2)  -- GOOD
printf("1+2={}", add 1, 2)   -- BAD - Parsed as printf("", add, 1, 2)
printf("1+2={}", (add 1, 2)) -- GOOD
printf("1+2={}", 1 add 2)    -- BAD - Parsed as printf("", 1(add(2)))
-- However I believe the tradeoff may be worth it for the expressive power
-- (see the `below` template in Ligi's compiler's source code)


-- Thus, in summary, Part 1 would:
---- Essentially allow defining new unary operators
---- NOT allow defining new unary operators (because of ambiguity)
